// CS 0445 Spring 2018// Modified BinarySearchTree class.  This class now extends// ComparableBinaryTree rather than BinaryTree.// Add your methods to the class so that it works as specified// in the assignment.  Note: This class will work without any modifications,// since it is not defining any new methods -- rather it is overriding already// existing methods to be more efficient.  However, you will lose credit if// you do not override the methods to take advantage of the fact that this is// a BST, not a general ComparableBinaryTree.package MyTreePackage;import java.util.Iterator;import java.util.*;/**   A class that implements the ADT binary search tree by extending BinaryTree.   Recursive version.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class BinarySearchTree<T extends Comparable<? super T>>             extends ComparableBinaryTree<T>              implements SearchTreeInterface<T>{	public boolean isBST(){	//always true		return true;	}		public T getMax(){		T maxNode = null;				if( getRootNode()==null ){		//getRootNode() 				return null;		}		else{			BinaryNode curNode = getRootNode();//root;			maxNode = (T)getLargestNode( curNode).getData();								}		return maxNode;		}		private BinaryNode getLargestNode(BinaryNode curNode){		BinaryNode largestNode = curNode;		if( curNode.hasRightChild()	) {		//compareTo(curNode,curNode.getLeftChild()) >0			largestNode = getLargestNode(curNode.getRightChild());		}				return largestNode;	}		public T getMin(){		T minNode = null;		if( getRootNode() ==null ){		//getRootNode()						return null;		}		else{			BinaryNode curNode = getRootNode();			minNode = (T)getSmallestNode( curNode).getData();		}		return minNode;			}				private BinaryNode getSmallestNode(BinaryNode curNode){		BinaryNode smallestNode = curNode;		if( curNode.hasLeftChild()	) {		//compareTo(curNode,curNode.getLeftChild()) >0			smallestNode = getSmallestNode(curNode.getLeftChild());		}				return smallestNode;	}			//feel like we just need to get the general position of the rootnode in the tree, and then we can give the location as the rank, in that case, we just need to go left and count?	//he might give u a leaf node, a middle node or a top node, the hard part is to figure out where the node is in the tree 	//just convert to an array and find the index, the bubble sort is no longer practical	public int rank(T data){					//find the node first, then rank it, hte data here has to be the binarynode though, because u coded to compare the nodes		ArrayList<BinaryNode> BinaryNodeArrayL = new ArrayList<BinaryNode>();		BinaryNodeArrayL = findAllNodes( super.getRootNode(), BinaryNodeArrayL);		//only find the child before the root?		boolean isLargest = true;		int index = 0;		BinaryNode temp =new BinaryNode(data);		for(int i =0;i<BinaryNodeArrayL.size()-1;i++){			if( compareTo(BinaryNodeArrayL.get(i), temp)>=0  ){				isLargest = false;				index = i;				break;	//break to ensure we return the smallest index			}		}		if(isLargest){			return BinaryNodeArrayL.size();//this means it is greater than any values		}			return index;	}  		//your get method here has big issues, feel like it is better just to do an inorder traverse 	//similar to the previous implementation,cut the size into half is the only difference	public T get(int i){		int totalSize = super.getRootNode().getNumberOfNodes();		if( i>totalSize || i<0){		//exceed the limit of the treenum, cornor cases			throw new IndexOutOfBoundsException();						}		ArrayList<BinaryNode> BinaryNodeArrayL = new ArrayList<BinaryNode>();		BinaryNodeArrayL = findAllNodes( super.getRootNode(), BinaryNodeArrayL);			//can only copy data up to the ith value, just set different modes, and pass i as a parameter and curindex, the second version stopps at index of i				return (T)BinaryNodeArrayL.get(i).getData();  	}			/*public ArrayList<BinaryNode> findPartialNodes(BinaryNode curNode,ArrayList<BinaryNode> BinaryNodeArray,int curIndex, int targetIndex){		//get the size first, then put all the nodes inan array, then compare the array, by anysorting, literaily		curIndex = BinaryNodeArray.size();		if(curIndex >=targetIndex){		//pause when over the size			return BinaryNodeArray;		}		else{			if(curNode.hasLeftChild() ){				BinaryNodeArray=findPartialNodes( curNode.getLeftChild(), BinaryNodeArray, curIndex, targetIndex);			}			BinaryNodeArray.add(curNode);			curIndex = BinaryNodeArray.size();			//System.out.println("adding "+curNode.getData()+"curIndex IS "+curIndex+" targetIndex is "+targetIndex );			if(curNode.hasRightChild() ){				BinaryNodeArray=findPartialNodes( curNode.getRightChild(), BinaryNodeArray, curIndex, targetIndex );			}			if(curNode.isLeaf() ){				return BinaryNodeArray;			}			}		return BinaryNodeArray;	}*/			//need to change the method here, can only search for the nodes that are greater than the curnode	//a little bit werid, i overwritted this method and it works, but if i don't, it won't???	//he said only the size of i can't be the entire size of arrays	public ArrayList<BinaryNode> findAllNodes(BinaryNode curNode,ArrayList<BinaryNode> BinaryNodeArray){		//get the size first, then put all the nodes inan array, then compare the array, by anysorting, literaily		if(curNode.hasLeftChild() ){			BinaryNodeArray=findAllNodes( curNode.getLeftChild(), BinaryNodeArray);		}		BinaryNodeArray.add(curNode);		if(curNode.hasRightChild() ){			BinaryNodeArray=findAllNodes( curNode.getRightChild(), BinaryNodeArray );		}		if(curNode.isLeaf() ){			return BinaryNodeArray;		}		return BinaryNodeArray;	}			public void setRootNode(BinaryNode<T> rootNode){	//maybe have issues		 super.setRootNode(rootNode);	}	public BinarySearchTree()   {      super();   } // end default constructor   public BinarySearchTree(T rootEntry)   {      //super();      super.setRootNode(new BinaryNode<>(rootEntry));   } // end constructor   public void setTree(T rootData) // Disable setTree (see Segment 25.6)   {      throw new UnsupportedOperationException();   } // end setTree   public void setTree(T rootData, BinaryTreeInterface<T> leftTree,                                    BinaryTreeInterface<T> rightTree)   {      throw new UnsupportedOperationException();   } // end setTree  	public T getEntry(T entry)	{	   return findEntry(getRootNode(), entry);	} // end getEntry   // Recursively finds the given entry in the binary tree rooted at the given node.	private T findEntry(BinaryNode<T> rootNode, T entry)	{	      T result = null;      if (rootNode != null)      {         T rootEntry = rootNode.getData();         if (entry.equals(rootEntry))            result = rootEntry;         else if (entry.compareTo(rootEntry) < 0)            result = findEntry(rootNode.getLeftChild(), entry);         else            result = findEntry(rootNode.getRightChild(), entry);      } // end if      return result;	} // end findEntry		public boolean contains(T entry)	{		return getEntry(entry) != null;	} // end contains	   public T add(T newEntry)   {      T result = null;      if (isEmpty())         setRootNode(new BinaryNode<>(newEntry));      else         result = addEntry(getRootNode(), newEntry);             return result;   } // end add   // Adds newEntry to the nonempty subtree rooted at rootNode.   private T addEntry(BinaryNode<T> rootNode, T newEntry)   {      assert rootNode != null;      T result = null;      int comparison = newEntry.compareTo(rootNode.getData());      if (comparison == 0)      {         result = rootNode.getData();         rootNode.setData(newEntry);      }      else if (comparison < 0)      {         if (rootNode.hasLeftChild())            result = addEntry(rootNode.getLeftChild(), newEntry);         else            rootNode.setLeftChild(new BinaryNode<>(newEntry));      }      else      {         assert comparison > 0;         if (rootNode.hasRightChild())            result = addEntry(rootNode.getRightChild(), newEntry);         else            rootNode.setRightChild(new BinaryNode<>(newEntry));      } // end if      return result;   } // end addEntry	public T remove(T entry)   {      ReturnObject oldEntry = new ReturnObject(null);      BinaryNode<T> newRoot = removeEntry(getRootNode(), entry, oldEntry);      setRootNode(newRoot);      return oldEntry.get();   } // end remove	// Removes an entry from the tree rooted at a given node.   // Parameters:   //    rootNode  A reference to the root of a tree.   //    entry  The object to be removed.   //    oldEntry  An object whose data field is null.   // Returns:  The root node of the resulting tree; if entry matches   //           an entry in the tree, oldEntry's data field is the entry   //           that was removed from the tree; otherwise it is null.   private BinaryNode<T> removeEntry(BinaryNode<T> rootNode, T entry,                                     ReturnObject oldEntry)   {      if (rootNode != null)      {         T rootData = rootNode.getData();         int comparison = entry.compareTo(rootData);         if (comparison == 0)       // entry == root entry         {            oldEntry.set(rootData);            rootNode = removeFromRoot(rootNode);         }         else if (comparison < 0)   // entry < root entry         {            BinaryNode<T> leftChild = rootNode.getLeftChild();            BinaryNode<T> subtreeRoot = removeEntry(leftChild, entry, oldEntry);            rootNode.setLeftChild(subtreeRoot);         }         else                       // entry > root entry         {            BinaryNode<T> rightChild = rootNode.getRightChild();            rootNode.setRightChild(removeEntry(rightChild, entry, oldEntry));         } // end if      } // end if      return rootNode;   } // end removeEntry	// Removes the entry in a given root node of a subtree.   // Parameter:   //    rootNode  A reference to the root of the subtree.   // Returns:  The root node of the revised subtree.   private BinaryNode<T> removeFromRoot(BinaryNode<T> rootNode)   {      // Case 1: rootNode has two children       if (rootNode.hasLeftChild() && rootNode.hasRightChild())      {         // Find node with largest entry in left subtree         BinaryNode<T> leftSubtreeRoot = rootNode.getLeftChild();         BinaryNode<T> largestNode = findLargest(leftSubtreeRoot);         // Replace entry in root         rootNode.setData(largestNode.getData());         // Remove node with largest entry in left subtree         rootNode.setLeftChild(removeLargest(leftSubtreeRoot));      } // end if       // Case 2: rootNode has at most one child      else if (rootNode.hasRightChild())         rootNode = rootNode.getRightChild();      else         rootNode = rootNode.getLeftChild();             // Assertion: If rootNode was a leaf, it is now null      return rootNode;    } // end removeEntry   // Finds the node containing the largest entry in a given tree.   // Parameter:   //    rootNode  A reference to the root node of the tree.   // Returns:  The node containing the largest entry in the tree.   private BinaryNode<T> findLargest(BinaryNode<T> rootNode)   {      if (rootNode.hasRightChild())         rootNode = findLargest(rootNode.getRightChild());             return rootNode;   } // end findLargest	// Removes the node containing the largest entry in a given tree.   // Parameter:   //    rootNode  A reference to the root node of the tree.   // Returns:  The root node of the revised tree.   private BinaryNode<T> removeLargest(BinaryNode<T> rootNode)   {      if (rootNode.hasRightChild())      {         BinaryNode<T> rightChild = rootNode.getRightChild();         rightChild = removeLargest(rightChild);         rootNode.setRightChild(rightChild);      }      else          rootNode = rootNode.getLeftChild();             return rootNode;   } // end removeLargest	private class ReturnObject	{		private T item;					private ReturnObject(T entry)		{			item = entry;		} // end constructor				public T get()		{			return item;		} // end get		public void set(T entry)		{			item = entry;		} // end set	} // end ReturnObject		// **************************************************	// Override the methods specified in Assignment 4 below	// **************************************************} // end BinarySearchTree