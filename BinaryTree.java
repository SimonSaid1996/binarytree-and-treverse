// CS 0445 Spring 2018// Modified BinaryTree class.  I have implemented one of the required methods// for you -- see (far) below.  You must complete the implementations for the // remaining methods.  You may NOT use any of the Iterator methods in the// implementations of your methods.//plottree method is partially using codes from   http://dept.cs.williams.edu/~freund/cs136-073/lectures/lecture22/infinite-cleanedup/BinaryTreeView.javapackage MyTreePackage;import java.util.*;import java.io.*;	// Needed for Assignment 4 methodsimport java.util.Iterator;import java.util.NoSuchElementException;import StackAndQueuePackage.*; // Needed by tree iteratorsimport javax.swing.*;import java.awt.*;import java.awt.event.*;/**   A class that implements the ADT binary tree.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/import java.lang.Object;public class BinaryTree<T> implements BinaryTreeInterface<T>{//////////////////////////////// this part of the code is adopted from  http://dept.cs.williams.edu/~freund/cs136-073/lectures/lecture22/infinite-cleanedup/BinaryTreeView.java with minor changes	public class BinaryTreeView<E> extends JPanel {		/* The tree currently being display */		protected BinaryNode<E> tree;		/* The max. getHeight of any tree drawn so far.  This       is used to avoid the tree jumping around when nodes       are removed from the tree. */		protected int maxHeight;		/* The font for the tree nodes. */		protected Font font = new Font("Roman", 0, 14);    		public BinaryTreeView(BinaryNode<E> tree, int width, int getHeight) {			//Initialize drawing colors, border, opacity.			setBackground(Color.white);			setForeground(Color.black);			// Create window and make it so hitting the close icon			// will terminate the program			JFrame f = new JFrame("BinaryNode View");			f.addWindowListener(new WindowAdapter() {				public void windowClosing(WindowEvent e) {                    System.exit(0);                }            });        			f.getContentPane().add(this, BorderLayout.CENTER);			f.setSize(new Dimension(width, getHeight));			f.setVisible(true);        			// install initial tree.			setTree(tree);		}				/*		* Set the display to show the given tree.		*/ 		public void setTree(BinaryNode<E> t) {			tree = t;			maxHeight = tree.getHeight();		}				public void refresh() {			paintImmediately(0,0, getWidth(), getHeight());		}				/*		* Draw the contents of the tree into the given Graphics		* context.		* It will place all info between minX and maxX in the x-direction,		* starting at location y in the y-direction.  Levels of the tree		* will be separated by yStep pixels.		*/		protected void drawTree(Graphics g, int minX, int maxX,                             int y, int yStep, BinaryNode<E> tree) {			String s = tree.getData().toString();        			g.setFont(font);			FontMetrics fm = g.getFontMetrics();			int width = fm.stringWidth(s);			int getHeight = fm.getHeight();			int xSep = Math.min((maxX - minX)/8, 10);			g.drawString(s, (minX + maxX)/2 - width/2, y + yStep/2);			if (tree.getLeftChild()!=null) {				// if getLeftChild tree not empty, draw line to it and recursively				// draw that tree				g.drawLine((minX + maxX)/2 - xSep, y + yStep/2 + 5,						(minX + (minX + maxX)/2) / 2, 						y + yStep + yStep/2 - getHeight);				drawTree(g, minX, (minX + maxX)/2, y + yStep, yStep, tree.getLeftChild());			}			if (tree.getRightChild()!=null) {				// same thing for getRightChild subtree.				g.drawLine((minX + maxX)/2 + xSep, y + yStep/2 + 5,						(maxX + (minX + maxX)/2) / 2, 						y + yStep + yStep/2 - getHeight);				drawTree(g, (minX + maxX)/2, maxX, y + yStep, yStep, tree.getRightChild());			}    }    /*     * paint method unherited from the Swing library.  Just     * calls drawTree whenever the window needs to be repainted.     */    protected void paintComponent(Graphics g) {        super.paintComponent(g);      //clears the background        int width = getWidth();        int getHeight = getHeight();        maxHeight = Math.max(tree.getHeight(), maxHeight);        int treeHeight = maxHeight;        drawTree(g, 0, width, 0, getHeight / (treeHeight + 1), tree);    }	}///////////////////////////////////////////////////////////////	   private BinaryNode<T> root;   public void drawBTree(){	   BinaryTreeView<T> btv = new BinaryTreeView<T>(root, 400, 400);       btv.refresh();   }      public BinaryTree()   {      root = null;   } // end default constructor   public BinaryTree(T rootData)   {      root = new BinaryNode<>(rootData);   } // end constructor   public BinaryTree(T rootData, BinaryTree<T> leftTree,                                  BinaryTree<T> rightTree)   {      privateSetTree(rootData, leftTree, rightTree);   } // end constructor   public boolean isFull(){	   	   //System.out.println("ok, this is trivial");	   return root.isFull();   }		// Return true if the current BT		// is a full tree and false otherwise.  See course notes for		// definition of a full tree.   public boolean isBalanced(int k){	   //System.out.println("guess this is trivial 2");	   return root. isBalanced( k );   }	// Return true for the current		   public void setTree(T rootData)   {      root = new BinaryNode<>(rootData);   } // end setTree   public void setTree(T rootData, BinaryTreeInterface<T> leftTree,                                   BinaryTreeInterface<T> rightTree)   {      privateSetTree(rootData, (BinaryTree<T>)leftTree,                                (BinaryTree<T>)rightTree);   } // end setTree	private void privateSetTree(T rootData, BinaryTree<T> leftTree, 	                                        BinaryTree<T> rightTree)	{      root = new BinaryNode<>(rootData);      if ((leftTree != null) && !leftTree.isEmpty())         root.setLeftChild(leftTree.root);             if ((rightTree != null) && !rightTree.isEmpty())      {         if (rightTree != leftTree)            root.setRightChild(rightTree.root);         else            root.setRightChild(rightTree.root.copy());      } // end if      if ((leftTree != null) && (leftTree != this))         leftTree.clear();              if ((rightTree != null) && (rightTree != this))         rightTree.clear();	} // end privateSetTree	public T getRootData()	{		if (isEmpty())			throw new EmptyTreeException();		else         return root.getData();	} // end getRootData	public boolean isEmpty()	{      return root == null;	} // end isEmpty	public void clear()	{      root = null;	} // end clear	protected void setRootData(T rootData)	{      root.setData(rootData);	} // end setRootData		// CS 0445 Spring 2018 I changed this from protected to public	public void setRootNode(BinaryNode<T> rootNode)	{      root = rootNode;	} // end setRootNode	protected BinaryNode<T> getRootNode()	{      return root;	} // end getRootNode	public int getHeight()	{      return root.getHeight();	} // end getHeight	public int getNumberOfNodes()	{      return root.getNumberOfNodes();	} // end getNumberOfNodes	public Iterator<T> getPreorderIterator()	{		return new PreorderIterator();		} // end getPreorderIterator	public Iterator<T> getInorderIterator()	{		return new InorderIterator();		} // end getInorderIterator		public Iterator<T> getPostorderIterator()	{		return new PostorderIterator();		} // end getPostorderIterator	public Iterator<T> getLevelOrderIterator()	{		return new LevelOrderIterator();		} // end getLevelOrderIterator	private class PreorderIterator implements Iterator<T>	{		private StackInterface<BinaryNode<T>> nodeStack;				public PreorderIterator()		{			nodeStack = new LinkedStack<>();			if (root != null)				nodeStack.push(root);		} // end default constructor				public boolean hasNext() 		{			return !nodeStack.isEmpty();		} // end hasNext				public T next()		{			BinaryNode<T> nextNode;						if (hasNext())			{				nextNode = nodeStack.pop();				BinaryNode<T> leftChild = nextNode.getLeftChild();				BinaryNode<T> rightChild = nextNode.getRightChild();								// Push into stack in reverse order of recursive calls				if (rightChild != null)					nodeStack.push(rightChild);									if (leftChild != null)					nodeStack.push(leftChild);			}			else			{				throw new NoSuchElementException();			}					return nextNode.getData();		} // end next			public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end PreorderIterator   public void iterativePreorderTraverse()   {      StackInterface<BinaryNode<T>> nodeStack = new LinkedStack<>();      if (root != null)         nodeStack.push(root);      BinaryNode<T> nextNode;      while (!nodeStack.isEmpty())      {			nextNode = nodeStack.pop();			BinaryNode<T> leftChild = nextNode.getLeftChild();			BinaryNode<T> rightChild = nextNode.getRightChild();						// Push into stack in reverse order of recursive calls			if (rightChild != null)				nodeStack.push(rightChild);         			if (leftChild != null)				nodeStack.push(leftChild);                  System.out.print(nextNode.getData() + " ");      } // end while   } // end iterativePreorderTraverse   	private class InorderIterator implements Iterator<T>	{      private StackInterface<BinaryNode<T>> nodeStack;      private BinaryNode<T> currentNode;      public InorderIterator()      {         nodeStack = new LinkedStack<>();         currentNode = root;      } // end default constructor      public boolean hasNext()       {         return !nodeStack.isEmpty() || (currentNode != null);      } // end hasNext      public T next()      {         BinaryNode<T> nextNode = null;         // Find leftmost node with no left child         while (currentNode != null)         {            nodeStack.push(currentNode);            currentNode = currentNode.getLeftChild();         } // end while         // Get leftmost node, then move to its right subtree         if (!nodeStack.isEmpty())         {            nextNode = nodeStack.pop();            assert nextNode != null; // Since nodeStack was not empty                                     // before the pop            currentNode = nextNode.getRightChild();         }         else            throw new NoSuchElementException();         return nextNode.getData();       } // end next      public void remove()      {         throw new UnsupportedOperationException();      } // end remove	} // end InorderIterator   public void iterativeInorderTraverse()   {      StackInterface<BinaryNode<T>> nodeStack = new LinkedStack<>();      BinaryNode<T> currentNode = root;            while (!nodeStack.isEmpty() || (currentNode != null))      {         // Find leftmost node with no left child         while (currentNode != null)         {            nodeStack.push(currentNode);            currentNode = currentNode.getLeftChild();         } // end while                  // Visit leftmost node, then traverse its right subtree         if (!nodeStack.isEmpty())         {            BinaryNode<T> nextNode = nodeStack.pop();            assert nextNode != null; // Since nodeStack was not empty                                     // before the pop            System.out.print(nextNode.getData() + " ");            currentNode = nextNode.getRightChild();         } // end if      } // end while   } // end iterativeInorderTraverse   	private class PostorderIterator implements Iterator<T>	{		private StackInterface<BinaryNode<T>> nodeStack;		private BinaryNode<T> currentNode;				public PostorderIterator()		{			nodeStack = new LinkedStack<>();			currentNode = root;		} // end default constructor				public boolean hasNext()		{			return !nodeStack.isEmpty() || (currentNode != null);		} // end hasNext      public T next()      {         boolean foundNext = false;         BinaryNode<T> leftChild, rightChild, nextNode = null;                  // Find leftmost leaf         while (currentNode != null)         {            nodeStack.push(currentNode);            leftChild = currentNode.getLeftChild();            if (leftChild == null)               currentNode = currentNode.getRightChild();            else               currentNode = leftChild;         } // end while                  // Stack is not empty either because we just pushed a node, or         // it wasn't empty to begin with since hasNext() is true.         // But Iterator specifies an exception for next() in case         // hasNext() is false.                  if (!nodeStack.isEmpty())         {            nextNode = nodeStack.pop();            // nextNode != null since stack was not empty before pop                        BinaryNode<T> parent = null;            if (!nodeStack.isEmpty())            {               parent = nodeStack.peek();               if (nextNode == parent.getLeftChild())                  currentNode = parent.getRightChild();               else                  currentNode = null;            }            else               currentNode = null;         }         else         {            throw new NoSuchElementException();         } // end if                  return nextNode.getData();      } // end next		public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end PostorderIterator		private class LevelOrderIterator implements Iterator<T>	{		private QueueInterface<BinaryNode<T>> nodeQueue;				public LevelOrderIterator()		{			nodeQueue = new LinkedQueue<>();			if (root != null)				nodeQueue.enqueue(root);		} // end default constructor				public boolean hasNext() 		{			return !nodeQueue.isEmpty();		} // end hasNext				public T next()		{			BinaryNode<T> nextNode;						if (hasNext())			{				nextNode = nodeQueue.dequeue();				BinaryNode<T> leftChild = nextNode.getLeftChild();				BinaryNode<T> rightChild = nextNode.getRightChild();								// Add to queue in order of recursive calls				if (leftChild != null)					nodeQueue.enqueue(leftChild);				if (rightChild != null)					nodeQueue.enqueue(rightChild);			}			else			{				throw new NoSuchElementException();			}					return nextNode.getData();		} // end next			public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end LevelOrderIterator		// *******************************	// Assignment 4 Methods Start Here	// *******************************	// I am giving you the code for this method so you can see how the recursion	// works and how you can utilize Object files. 	public void saveInorder(String fileName)	{		try		{			ObjectOutputStream OS = new ObjectOutputStream(				   new FileOutputStream(fileName));		// Create the object file			int n = getNumberOfNodes();						//Integer n2 = new Integer(n);						OS.writeInt(n);		// output the number of nodes				// Call the recursive method to output the nodes themselves			RecWriteTree(OS, (BinaryNode<T>)getRootNode());			OS.close();		}		catch (IOException e)		{			System.out.println("Writing problem");		}	}	public void RecWriteTree(ObjectOutputStream OS, BinaryNode<T> node)	{		if (node != null)	// Base case -- do nothing for empty node		{			try			{		// Recursively output left subtree				RecWriteTree(OS, (BinaryNode<T>) node.getLeftChild());					// output data in current node				OS.writeObject(node.getData());					// Recursively output right subtree				RecWriteTree(OS, (BinaryNode<T>) node.getRightChild());			}			catch (IOException e)			{				System.out.println("Rec Writing Problem" + e);			}		}	}		public void buildInorder(String fileName){ // Build a balanced BT		int readLineNum = 0;		try		{			ObjectInputStream  OS = new ObjectInputStream (				   new FileInputStream(fileName));		// Create the object file			readLineNum =  OS.readInt();			BinaryNode rootNode = new BinaryNode();			int FullTreeheight = (int)(Math.log(readLineNum+1)/Math.log(2));	//the height of 2^(k-1) if 2^k < length			int maxTreeHeight = FullTreeheight;			int subtreeNum = readLineNum;//(int )Math.ceil( (readLineNum) ); //(readLineNum-1)/2;			if( (Math.pow(2, FullTreeheight)) < readLineNum )	//situation where the tree have more nodes than the full tree				maxTreeHeight = maxTreeHeight+1;			int[] infoArray = {0,readLineNum,1,maxTreeHeight,subtreeNum,0};			infoArray = buildInorderArray(rootNode,rootNode , infoArray, OS);   //0,readLineNum,1,maxTreeHeight,false,subtreeNum			root = rootNode;			OS.close();		}		catch (IOException e)   //catch ( ClassNotFoundException e )		{			System.out.println("Reading problem "+e);		}			}		//now need to recursively build a binarytree   (Math.log(65536)/Math.log(2))	//index 0 is the currentnum of node, 1 is totalnodenum, 2 is nodelevel, 3 is the maxtreelevel, 4 is the subtreeNum and the last one is the leftnodeset (0 is not set, 1 is set)	private int[] buildInorderArray(BinaryNode rootNode, BinaryNode curNode, int[] infoArray, ObjectInputStream  OS){		try		{			int prevSubTree = 0;			if(  infoArray[2]==infoArray[3] || infoArray[4]==1 ){ //base case, return  //infoArray[4] ==1  ||				curNode.setData( OS.readObject() );				infoArray[0] = infoArray[0] +1;				infoArray[4] = 1;		//the last level subtree can only be itself				return infoArray;			}			else{								if(  infoArray[2] <infoArray[3] ){	//recursive case, go to the next level    //curLevel<maxLevel and    //&& infoArray[4]!= 1					curNode.setLeftChild(new BinaryNode() );					infoArray[2] = infoArray[2] + 1;					prevSubTree = infoArray[4]-1;					if(infoArray[4]%2==1){	//when it is odd, we just divide by 2						infoArray[4] =  (int ) (infoArray[4]-1)/2  ;							}					else{	//even cases, we do something else						infoArray[4] = (int ) (infoArray[4]-1)-(infoArray[4]-1)/2  ;					}										infoArray =  buildInorderArray(rootNode,curNode.getLeftChild(), infoArray,OS);					if(infoArray[4] ==0 ){	//special case, if all the nodes here are gone, we need to pass prevSubTree back						if(prevSubTree%2==1){	//when it is odd, we just divide by 2							infoArray[4] =  (int ) (prevSubTree-1)/2+1  ;								}						else{	//even cases, we do something else							infoArray[4] = (int ) (prevSubTree)/2  ; //(prevSubTree-1)-						}					}									}						infoArray[0] = infoArray[0]+1;					curNode.setData( OS.readObject() );//kind of doubt this part, the scanned shit might have issues, this is the middle node 					infoArray[4] = prevSubTree -infoArray[4];				//u need to somehow think about updating the infoArray[4]										//think about when infoArray need to be 0 and when need to be something else					//supposed to return infoArray[4] as 3 here					infoArray[2] = infoArray[2]-1;					//this part got issues, think more 					if ( infoArray[4]!= 0 ){ //&& infoArray[4] !=1						//infoArray[2]<maxLevel and	 //infoArray[5] ==1 && (prevSubTree- infoArray[4]!=0)						curNode.setRightChild( new BinaryNode() );						infoArray[2] = infoArray[2] + 1;						infoArray =  buildInorderArray(rootNode,curNode.getRightChild(), infoArray,OS);							infoArray[2] = infoArray[2] -1 ;						infoArray[4] = prevSubTree+1;	//reset the previous tree so that we can get the correct number																	}	 						}						}		catch (IOException e)   //catch ( ClassNotFoundException e )		{			System.out.println("Reading problem "+e);		}		catch(ClassNotFoundException e )		{			System.out.println("classNot Found");		}//should distinguish a special case and a normal case here to return		if( infoArray[0] == infoArray[1] ){   //reaching the number of 13 is when exiting						return infoArray;		}			return infoArray;	}				private void traverseTree(BinaryTree BT){		BinaryNode start = BT.root;		traverInOrderTree(start );	}		private void traverInOrderTree(BinaryNode cur ){		if( cur.hasLeftChild() ){			traverInOrderTree( cur.getLeftChild() );		}		System.out.println("cur node is "+cur.getData() );		if(cur.hasRightChild()){			traverInOrderTree( cur.getRightChild() );		}		if(cur.isLeaf()){			//System.out.println("cur Node is"+cur.getData() );		}			}		public static BinaryNode<Integer> init1()	{		BinaryNode<Integer> temp1 = new BinaryNode<Integer>(new Integer(60));		BinaryNode<Integer> temp2 = new BinaryNode<Integer>(new Integer(30));		BinaryNode<Integer> temp3 = new BinaryNode<Integer>(new Integer(80), temp1, temp2);		temp1 = new BinaryNode<Integer>(new Integer(20));		temp2 = new BinaryNode<Integer>(new Integer(15), temp1, temp3);		temp3 = temp2;		temp2 = new BinaryNode<Integer>(new Integer(50));		temp1 = new BinaryNode<Integer>(new Integer(40), null, temp2);		temp2 = new BinaryNode<Integer>(new Integer(75));		BinaryNode<Integer> temp4 = new BinaryNode<Integer>(new Integer(65), temp1, temp2);		temp1 = new BinaryNode<Integer>(new Integer(90), temp4, temp3);		return temp1;	}		public static BinaryNode<Integer> init2()	{		BinaryNode<Integer> temp1 = new BinaryNode<Integer>(new Integer(17));		BinaryNode<Integer> temp2 = new BinaryNode<Integer>(new Integer(20), temp1, null);		temp1 = new BinaryNode<Integer>(new Integer(10));		BinaryNode<Integer> temp3 = new BinaryNode<Integer>(new Integer(15), temp1, temp2);		temp2 = new BinaryNode<Integer>(new Integer(30));		temp1 = new BinaryNode<Integer>(new Integer(25), temp3, temp2);		temp3 = temp1;		temp1 = new BinaryNode<Integer>(new Integer(55));		temp2 = new BinaryNode<Integer>(new Integer(70));		BinaryNode<Integer> temp4 = new BinaryNode<Integer>(new Integer(60), temp1, temp2);		temp1 = new BinaryNode<Integer>(new Integer(80));		temp2 = new BinaryNode<Integer>(new Integer(85), temp1, null);		temp1 = new BinaryNode<Integer>(new Integer(75), temp4, temp2);		temp4 = new BinaryNode<Integer>(new Integer(50), temp3, temp1);		return temp4;	}		} // end BinaryTree