// CS 0445 Spring 2018// Assignment 4// Interface for the additional operations in the ComparableBinaryTree//the bubble sort method is referenced from https://www.geeksforgeeks.org/bubble-sort/package MyTreePackage;import java.lang.Object;import java.util.*;public class ComparableBinaryTree<T extends Comparable<? super T>> extends BinaryTree<T> implements ComparableTreeInterface<T>{		public ComparableBinaryTree()	{	  super();	} // end default constructor	public ComparableBinaryTree(T rootData)	{	  super(rootData);	} // end constructor	public ComparableBinaryTree(T rootData, ComparableBinaryTree<T> leftTree,                                  ComparableBinaryTree<T> rightTree)	{      privateSetTree(rootData, leftTree, rightTree);	} // end constructor		public int compareTo(BinaryNode<T> m1, BinaryNode<T> m2)    {		return m1.getData() .compareTo(m2.getData() );    }	   	private void privateSetTree(T rootData, ComparableBinaryTree<T> leftTree, 	                                        ComparableBinaryTree<T> rightTree)	{		super.setRootData(rootData);      if ((leftTree != null) && !leftTree.isEmpty())		super.getRootNode().setLeftChild( leftTree.getRootNode() );      if ((rightTree != null) && !rightTree.isEmpty())      {         if (rightTree != leftTree)			super.getRootNode().setRightChild(rightTree.getRootNode() );	         else			super.getRootNode().setRightChild(rightTree.getRootNode().copy() );      } // end if      if ((leftTree != null) && (leftTree != this))         leftTree.clear();              if ((rightTree != null) && (rightTree != this))         rightTree.clear();	} // end privateSetTree		public boolean isFull(){	   	   return super.getRootNode().isFull();	}			public void setRootNode(BinaryNode<T> rootNode)	{	  super.setRootNode(rootNode);	} // end setRootNo			// If the tree is not empty, return the maximum
	// value in the tree; otherwise return null
	public T getMax(){		T maxData = null;				if( super.getRootNode() ==null ){	//why is the root euqal to null here ???			return null;		}		else{			BinaryNode curNode = super.getRootNode();			BinaryNode largestNode = super.getRootNode();									largestNode = getLargestNode( curNode,  largestNode);			maxData = (T)largestNode.getData();					}		return maxData;	}		private BinaryNode getLargestNode(BinaryNode curNode, BinaryNode largestNode){		if( curNode.hasLeftChild()	) {		//compareTo(curNode,curNode.getLeftChild()) >0			largestNode = getLargestNode( curNode.getLeftChild(),  largestNode);			if(compareTo(curNode,largestNode) >0){				largestNode = curNode;			}		}		if(curNode.hasRightChild()){	//compareTo(curNode,curNode.getLeftChild()) <0 					largestNode = getLargestNode( curNode.getRightChild(),  largestNode);			if(compareTo(curNode,largestNode) >0){				largestNode = curNode;			}		}		if( curNode.isLeaf() ){			if(compareTo(curNode,largestNode) >0){				return curNode;			}		}				return largestNode;	}			private BinaryNode getSmallestNode(BinaryNode curNode, BinaryNode smallestNode){		if( curNode.hasLeftChild()	) {		//compareTo(curNode,curNode.getLeftChild()) >0			smallestNode = getSmallestNode( curNode.getLeftChild(),  smallestNode);			if(compareTo(curNode,smallestNode) <0){				smallestNode = curNode;			}		}		if(curNode.hasRightChild()){	//compareTo(curNode,curNode.getLeftChild()) <0 					smallestNode = getSmallestNode( curNode.getRightChild(),  smallestNode);			if(compareTo(curNode,smallestNode) <0){				smallestNode = curNode;			}		}		if( curNode.isLeaf() ){			if(compareTo(curNode,smallestNode) <0){				return curNode;			}		}				return smallestNode;	}		
	// If the tree is not empty, return the minimum
	// value in the tree; otherwise return null
	public T getMin(){		T minData = null;		if( super.getRootNode()==null ){				return null;		}		else{			BinaryNode curNode = super.getRootNode();			BinaryNode smalLestNode = super.getRootNode();			smalLestNode = getSmallestNode( curNode,  smalLestNode);			minData = (T)smalLestNode.getData();		}		return minData;	}	
	// Return true if the the tree meets the
	// recursive definition of a BST; else
	// return false	public boolean isBST(){				BinaryNode curNode = super.getRootNode();		curNode = checkBST( curNode);		if(curNode ==null){			return false;		}		return true;	}			private BinaryNode checkBST(BinaryNode curNode){// boolean BSTTrue		BinaryNode leftNode = null;		BinaryNode rightNode= null;		if(curNode!= null){			if( curNode.hasLeftChild()	) {		//compareTo(curNode,curNode.getLeftChild()) >0				leftNode = checkBST( curNode.getLeftChild());				if(leftNode !=null){					if(compareTo(curNode,leftNode) <0){						return null;					}				}				else{					return null;				}						}			if(curNode.hasRightChild()){	//compareTo(curNode,curNode.getLeftChild()) <0 						rightNode = checkBST( curNode.getRightChild()/*,  BSTTrue*/);				leftNode = checkBST( curNode.getLeftChild()/*,  BSTTrue*/);				if(rightNode !=null){					if(compareTo(curNode,rightNode) >0){						return null;					}				}				else{					return null;				}						}			if( curNode.isLeaf() ){				return curNode;			}			}			return curNode;	}		// Return the rank of data in the tree	// with 0 being the smallest answer and	// N being the largest answer.  data does not have to be 	// present in the tree.  If duplicates are present in the tree	// this answer should be minimized.	public int rank(T data){					//find the node first, then rank it, hte data here has to be the binarynode though, because u coded to compare the nodes		ArrayList<BinaryNode> BinaryNodeArrayL = new ArrayList<BinaryNode>();		BinaryNodeArrayL = findAllNodes( super.getRootNode(), BinaryNodeArrayL);				BinaryNodeArrayL = bubbleSort(BinaryNodeArrayL);		boolean isLargest = true;		int index = 0;		BinaryNode temp =new BinaryNode(data);		for(int i =0;i<BinaryNodeArrayL.size();i++){			if( compareTo(BinaryNodeArrayL.get(i), temp)>=0  ){				isLargest = false;				index = i;				break;	//break to ensure we return the smallest index			}		}		if(isLargest){			return BinaryNodeArrayL.size();//this means it is greater than any values		}				return index;	}  				// Return the value in the tree with rank	// i in the ordering.  If there are duplicates	// the first occurrence should be returned.	public T get(int i){		int totalSize = super.getRootNode().getNumberOfNodes();		ArrayList<BinaryNode> BinaryNodeArrayL = new ArrayList<BinaryNode>();				if( i > totalSize || i < 0){		//exceed the limit of the treenum, cornor cases						throw new IndexOutOfBoundsException();				}		BinaryNodeArrayL = findAllNodes( super.getRootNode(), BinaryNodeArrayL);		//he said we need to have only size of i+1		BinaryNodeArrayL.get(0);		BinaryNodeArrayL = bubbleSort(BinaryNodeArrayL);				return (T)BinaryNodeArrayL.get(i).getData();	}		public ArrayList<BinaryNode>  bubbleSort(ArrayList<BinaryNode> arrL)		//this part might have issues, cause he said we can't do iterative    {        int n = arrL.size();        for (int i = 0; i < n-1; i++)            for (int j = 0; j < n-i-1; j++)                if (compareTo(arrL.get( j), arrL.get(j+1))>0)//(arrL.get( j) > arrL.get(j+1))                {                    BinaryNode temp = arrL.get( j );					arrL.set(j,arrL.get(j+1));					arrL.set(j+1,temp);                }						return 	arrL;	    }		//code to findallnodes and put into an array	public ArrayList<BinaryNode> findAllNodes(BinaryNode curNode,ArrayList<BinaryNode> BinaryNodeArray){		//get the size first, then put all the nodes inan array, then compare the array, by anysorting, literaily		if(curNode.hasLeftChild() ){			BinaryNodeArray=findAllNodes( curNode.getLeftChild(), BinaryNodeArray);		}		//System.out.println("cur index is "+indx);		if(curNode.hasRightChild() ){			BinaryNodeArray=findAllNodes( curNode.getRightChild(), BinaryNodeArray );		}		if(curNode.isLeaf() ){			BinaryNodeArray.add(curNode);			return BinaryNodeArray;		}		BinaryNodeArray.add(curNode);		return BinaryNodeArray;	}			}