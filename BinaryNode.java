// CS 0445 Spring 2018// BinaryNode class for Assignment 4.  Add the methods specified in the// assignment sheet so that this class works correctly.  I have included// them with empty bodies below.//the drawNode method is adopted from https://stackoverflow.com/questions/13825582/trying-to-use-drawstring-method-to-print-a-namepackage MyTreePackage;/**   A class that represents nodes in a binary tree.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/import java.lang.*;import java.awt.Graphics2D;import java.awt.Graphics;import java.awt.Color;import javax.swing.JComponent;import javax.swing.JFrame;public class BinaryNode<T>{   private T             data;   private BinaryNode<T> leftChild;  // Reference to left child   private BinaryNode<T> rightChild; // Reference to right child	////////////////// the following part is adopted from the above website with slight modifications	public class NameComponent extends JComponent {		@Override		public void paintComponent(Graphics g) {			super.paintComponent(g);			Graphics2D g2 = (Graphics2D) g;			g2.setColor(Color.RED);			g2.drawString(String.valueOf(leftChild), 100, 100);			g2.drawString(String.valueOf(data), 200, 100);			g2.drawString(String.valueOf(rightChild), 300, 100);		}	}	////////////// change this into some messages		public  void drawNode () {	//method to draw the content of curNode		JFrame myFrame = new JFrame();		myFrame.setSize(400, 200);		myFrame.setTitle("Node");		myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);		NameComponent myName = new NameComponent();		myFrame.add(myName);			myFrame.setVisible(true);    }			   public BinaryNode()   {      this(null); // Call next constructor   } // end default constructor   public BinaryNode(T dataPortion)   {      this(dataPortion, null, null); // Call next constructor   } // end constructor   public BinaryNode(T dataPortion, BinaryNode<T> newLeftChild,                                    BinaryNode<T> newRightChild)   {      data = dataPortion;      leftChild = newLeftChild;      rightChild = newRightChild;   } // end constructor   /** Retrieves the data portion of this node.       @return  The object in the data portion of the node. */   public T getData()   {      return data;   } // end getData   /** Sets the data portion of this node.       @param newData  The data object. */   public void setData(T newData)   {      data = newData;   } // end setData   /** Retrieves the left child of this node.       @return  The node’s left child. */   public BinaryNode<T> getLeftChild()   {      return leftChild;   } // end getLeftChild   /** Sets this node’s left child to a given node.       @param newLeftChild  A node that will be the left child. */   public void setLeftChild(BinaryNode<T> newLeftChild)   {      leftChild = newLeftChild;   } // end setLeftChild   /** Detects whether this node has a left child.       @return  True if the node has a left child. */   public boolean hasLeftChild()   {      return leftChild != null;   } // end hasLeftChild   /** Retrieves the right child of this node.       @return  The node’s right child. */   public BinaryNode<T> getRightChild()   {      return rightChild;   } // end getRightChild      /** Sets this node’s right child to a given node.       @param newRightChild  A node that will be the right child. */   public void setRightChild(BinaryNode<T> newRightChild)   {      rightChild = newRightChild;   } // end setRightChild      /** Detects whether this node has a right child.       @return  True if the node has a right child. */   public boolean hasRightChild()   {      return rightChild != null;   } // end hasRightChild      /** Detects whether this node is a leaf.       @return  True if the node is a leaf. */   public boolean isLeaf()   {      return (leftChild == null) && (rightChild == null);   } // end isLeaf   /** Counts the nodes in the subtree rooted at this node.       @return  The number of nodes in the subtree rooted at this node. */   public int getNumberOfNodes()   {      int leftNumber = 0;      int rightNumber = 0;            if (leftChild != null)         leftNumber = leftChild.getNumberOfNodes();            if (rightChild != null)         rightNumber = rightChild.getNumberOfNodes();            return 1 + leftNumber + rightNumber;   } // end getNumberOfNodes      /** Computes the height of the subtree rooted at this node.       @return  The height of the subtree rooted at this node. */   public int getHeight()   {      return getHeight(this); // Call private getHeight   } // end getHeight   private int getHeight(BinaryNode<T> node)   {      int height = 0;      if (node != null)         height = 1 + Math.max(getHeight(node.getLeftChild()),                               getHeight(node.getRightChild()));                                   return height;   } // end getHeight   /** Copies the subtree rooted at this node.       @return  The root of a copy of the subtree rooted at this node. */   public BinaryNode<T> copy()   {      BinaryNode<T> newRoot = new BinaryNode<>(data);            if (leftChild != null)         newRoot.setLeftChild(leftChild.copy());            if (rightChild != null)         newRoot.setRightChild(rightChild.copy());            return newRoot;   } // end copy      	// **********************************	// Complete the additional methods below	// **********************************	// If the tree is a full tree, return true	// Otherwise, return false.  See notes for	// definition of full.		//n = 2k-1, this tree will be a Full Tree,n is the node number and k is the height	//need to count all the node number?	public boolean isFull()				{								//so in theory, the isFull tree also has to traverse to the bottom to check if the node number		//return true if both sides are full, else, return false		//why can't we just use gete height and get number of node methods to compare here?			return this.isBalanced(0);	}		//in this recursion, we need to check if the nodes have 2 children and if the leaf of the tree are at the same level 	//we also have to check the levels and the corresponding number of the decendents, which the methods are listed above	//not super sure???		// Return true if 1) the difference	// in height between the left and right subtrees is at most k,	// and 2) the left and right subtrees are both recursively	// k-balanced; return false otherwise	  	public boolean isBalanced(int k)		{		//isbalanced need to compare the left and right number of nodes, which have to traverse		boolean[] balanceChecker = {false, true};		balanceChecker = isBalanced( balanceChecker, k, this);		if ( balanceChecker[1]==false )			return false;		return true;	}		//backtracking, first reach the leaves, then return the left and right child's height	//index 0 stores if it is the leaf, index 1 stores if it is balanced or not	// curNode 0 is left child, curNode 1 is right child	private boolean[] isBalanced(boolean[] balanceChecker, int k, BinaryNode curNode){						if(curNode.isLeaf()){			balanceChecker[ 0 ] = true;			return balanceChecker;		}		else{			if(curNode.hasLeftChild() && curNode.hasRightChild()){ //have both child situation				balanceChecker = leftChild.isBalanced( balanceChecker, k, curNode.leftChild ); 	//check the left height here								int leftHeight = getHeight(curNode.getLeftChild());				balanceChecker = rightChild.isBalanced( balanceChecker,k, curNode.rightChild  ); 	//check the right height here				int rightHeight = getHeight(curNode.getRightChild());				if( Math.abs(leftHeight - rightHeight )>k ){					balanceChecker[ 1 ] = false;									}			}			else if(curNode.hasLeftChild() && !curNode.hasRightChild()){  //have only left child situation				balanceChecker = leftChild.isBalanced( balanceChecker,k, curNode.leftChild );				int leftHeight = getHeight(curNode.getLeftChild());				if(leftHeight >k){					balanceChecker[ 1 ] = false;				}			}			else if(!curNode.hasLeftChild() && curNode.hasRightChild()){ //have only right child situation					balanceChecker = rightChild.isBalanced( balanceChecker,k, curNode.rightChild );				int rightHeight = getHeight(curNode.getRightChild());				if(rightHeight >k){					balanceChecker[ 1 ] = false;				}			}		}		return balanceChecker;	}	} // end BinaryNode